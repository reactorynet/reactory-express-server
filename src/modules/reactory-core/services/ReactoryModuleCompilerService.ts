import fs from "fs";
import crypto from "crypto";
import path from "path";
import { cwd } from "process";
import Reactory from "@reactory/reactory-core";
import { ENVIRONMENT } from "@reactory/server-core/types/constants";

const util = require("util");
const exec = util.promisify(require("child_process").exec);

/**
 * Compute a SHA-1 checksum directly from a string buffer.
 * This avoids any file I/O race conditions by hashing in-memory data.
 */
const checksumFromString = (content: string, algo: string = "sha1"): string => {
  return crypto.createHash(algo).update(content, "utf8").digest("hex");
};

/**
 * Write a file durably using open/write/fsync/close to guarantee the data
 * is flushed to the filesystem before returning. Also ensures the parent
 * directory exists.
 */
const durableWriteFile = (filePath: string, content: string): void => {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  const fd = fs.openSync(filePath, "w");
  try {
    fs.writeSync(fd, content, 0, "utf8");
    fs.fsyncSync(fd);
  } finally {
    fs.closeSync(fd);
  }
};

/**
 * Safely delete a file if it exists. Handles concurrent deletion gracefully.
 */
const safeUnlink = (filePath: string): void => {
  try {
    fs.unlinkSync(filePath);
  } catch (err: any) {
    // ENOENT means the file is already gone -- that's fine
    if (err?.code !== "ENOENT") {
      throw err;
    }
  }
};

/**
 * Simple per-key async mutex to prevent concurrent compilations of the
 * same module. Each module id gets its own lock chain.
 */
const compileLocks = new Map<string, Promise<void>>();
const acquireCompileLock = (moduleId: string): { release: () => void; ready: Promise<void> } => {
  // Wait for any previous compilation of this module to finish
  const previous = compileLocks.get(moduleId) ?? Promise.resolve();
  let release: () => void;
  const gate = new Promise<void>((resolve) => { release = resolve; });
  compileLocks.set(moduleId, previous.then(() => gate));
  return { release: release!, ready: previous };
};

/**
 * Service class that provides access to forms for the logged in user
 */

interface IRollupOptions {
  outputFile: string;
  inputFile: string;
  enviroment: string;
  moduleName: string;
}

const DefaultRollupOptions = (options: IRollupOptions) => `
/**
 * DO NOT EDIT THIS FILE, IT IS AUTO GENERATED AND WILL BE 
 * OVERWRITTEN EVERY TIME THE SOURCE PLUGIN FILE CHANGES
 **/
import { babel } from "@rollup/plugin-babel";
import commonjs from "@rollup/plugin-commonjs";
import resolve from "@rollup/plugin-node-resolve";
import replace from "@rollup/plugin-replace";
import typescript from '@rollup/plugin-typescript';

const jsx = require('rollup-plugin-jsx');


const NODE_ENV = process.env.NODE_ENV || "development";

export default {
  input: "${options.inputFile}",
  output: {
    file: "${options.outputFile}",
    name: "${options.moduleName}",
    format: "umd",
    external: ['react', 'react-dom'],
    globals: ['React', 'window'],
    sourcemap: true
  },

  plugins: [
    replace({
      'process.env.NODE_ENV': JSON.stringify(NODE_ENV || "development"),
      preventAssignment: true
    }),
    commonjs({
      include: 'node_modules/**',
      exclude: [
        'node_modules/process-es6/**',
      ],   
    }),
    typescript({
      sourceMap: true
    }),        
    babel({
      exclude: 'node_modules/**',
      include: ['./src/**/*.ts', './src/**/*.js', './src/**/*.tsx'],
      babelHelpers: "bundled",
      sourceMaps: "both",
      extensions: ['.ts', '.tsx', '.js', '.jsx'],
      presets: [
        [
          "@babel/preset-env",
          {
            modules: false,
          }
        ],

        [
          "@babel/preset-react",          
        ],

        [
          "@babel/preset-typescript",          
        ]
      ],          
    }),
    jsx({ factory: 'React.createElement' }),
    resolve(),
  ],
};
`;

class ReactoryModuleCompilerService
  implements Reactory.Service.IReactoryModuleCompilerService
{
  name: string = "ReactoryModuleCompilerService";
  nameSpace: string = "core";
  version: string = "1.0.0";

  props: Reactory.Service.IReactoryServiceProps;
  context: Reactory.Server.IReactoryContext;

  fileService: Reactory.Service.IReactoryFileService;

  constructor(
    props: Reactory.Service.IReactoryServiceProps,
    context: Reactory.Server.IReactoryContext
  ) {
    this.props = props;
    this.context = context;
  }

  /**
   * These should only be called during development, and should not be used in production.
   * Compiled resources should be stored in a CDN and served from there.
   * @param module
   * @returns
   */
  async compileModule(
    module: Reactory.Forms.IReactoryFormModule
  ): Promise<Reactory.Forms.IReactoryFormResource> {
    const that = this;

    const runtimeBase = path.join(process.env.APP_DATA_ROOT, "plugins", "__runtime__");
    const sourceFile = path.join(runtimeBase, `src/source_${module.id}.${module.fileType}`);
    const compiledFile = path.join(runtimeBase, `lib/${module.id}.min.js`);

    // ---------------------------------------------------------------
    // Acquire a per-module lock so concurrent requests for the same
    // module are serialised.  This prevents one call's cleanup from
    // deleting files another call is still reading.
    // ---------------------------------------------------------------
    const lock = acquireCompileLock(module.id);
    await lock.ready;

    try {
      return await this.doCompileModule(module, sourceFile, compiledFile, runtimeBase);
    } catch (fatalError) {
      this.context.log(
        `Fatal error compiling module ${module.id}`,
        { fatalError },
        "error",
        ReactoryModuleCompilerService.reactory.id
      );
      return this.createFailureResource(module, compiledFile, "Unexpected compilation error");
    } finally {
      lock.release();
    }
  }

  /**
   * Internal compilation logic, called under the per-module lock.
   */
  private async doCompileModule(
    module: Reactory.Forms.IReactoryFormModule,
    sourceFile: string,
    compiledFile: string,
    runtimeBase: string,
  ): Promise<Reactory.Forms.IReactoryFormResource> {
    const that = this;

    let doCompile = false;
    let checksum = "";

    // ---------------------------------------------------------------
    // Compute the incoming source checksum in-memory -- no temp file
    // needed and no ReadStream race condition possible.
    // ---------------------------------------------------------------
    const newChecksum = checksumFromString(module.src, "sha1");

    if (!fs.existsSync(sourceFile) || !fs.existsSync(compiledFile)) {
      doCompile = true;
    } else {
      // The existing source file IS on disk, so use the fileService
      // ReadStream-based checksum -- but wrap it with a .catch so an
      // unhandled error event cannot crash the process.
      try {
        checksum = await this.fileService
          .generateFileChecksum(sourceFile, "sha1");
      } catch (checksumErr) {
        this.context.log(
          `Could not checksum existing source ${sourceFile}, will recompile`,
          { checksumErr },
          "warning",
          ReactoryModuleCompilerService.reactory.id
        );
        checksum = "";
      }

      if (newChecksum !== checksum) {
        doCompile = true;
      }
    }

    // ---------------------------------------------------------------
    // Compile with rollup if the source has changed
    // ---------------------------------------------------------------
    if (doCompile) {
      const result = await this.compileWithRollup(module, sourceFile, compiledFile, runtimeBase);

      if (!result.success) {
        const notification = `$reactory.createNotification("Compilation error on module ${module.id}, see console log for details", { type: 'warning' });`;
        const errorLogs = result.messages.map((msg) => {
          that.context.log("Error compiling module", { message: msg }, "error");
          return `$reactory.log("Compilation Failure for ${module.id} --> [${msg}]", { module: ${JSON.stringify(module)} }, 'error');`;
        });

        const failureScript = `
          if(window && window.reactory) {
            var $reactory = window.reactory.api;
            ${notification}
            ${errorLogs.join("\n")}
          }
        `;

        try {
          durableWriteFile(compiledFile, failureScript);
        } catch (writeErr) {
          that.context.log(
            `Failed to write failure script for module ${module.id}`,
            { writeErr },
            "error",
            ReactoryModuleCompilerService.reactory.id
          );
        }
      }

      checksum = newChecksum;
    }

    return {
      name: module.id,
      type: "script",
      uri: `${process.env.CDN_ROOT}plugins/__runtime__/lib/${module.id}.min.js?cs=${checksum}`,
      id: module.id,
      signature: checksum,
      signatureMethod: "sha1",
      crossOrigin: false,
      signed: true,
      expr: "",
      required: true,
      cacheProvider: "CDN",
    };
  }

  /**
   * Run rollup to bundle a module.
   * Uses durableWriteFile to guarantee the source and config are fully
   * flushed to disk before rollup is spawned.
   */
  private async compileWithRollup(
    module: Reactory.Forms.IReactoryFormModule,
    sourceFile: string,
    compiledFile: string,
    runtimeBase: string,
  ): Promise<{ success: boolean; messages: string[] }> {
    const result = { success: false, messages: [] as string[] };

    // Write the source file durably (open → write → fsync → close)
    durableWriteFile(sourceFile, module.src);

    const $config = DefaultRollupOptions({
      enviroment: process.env.NODE_ENV || "development",
      inputFile: sourceFile,
      outputFile: compiledFile,
      moduleName: `reactory-plugin-${module.id
        .replace(".", "-")
        .replace("@", "-")}`,
    });

    const rollupConfigFile = path.join(runtimeBase, `rollup.${module.id}.js`);
    durableWriteFile(rollupConfigFile, $config);

    try {
      const { stdout, stderr, error } = await exec(
        `npx rollup --config rollup.${module.id}.js`,
        { cwd: runtimeBase, encoding: "utf8" },
      );

      this.context.log(
        `Compiled resource ${module.id}`,
        { stdout, stderr, error },
        "debug",
        ReactoryModuleCompilerService.reactory.id,
      );

      if (fs.existsSync(compiledFile)) {
        result.success = true;
      }
    } catch (execErr) {
      this.context.log(
        `Error executing rollup for module ${module.id}`,
        { execErr },
        "error",
        ReactoryModuleCompilerService.reactory.id,
      );
    }

    return result;
  }

  /**
   * Creates a failure resource when compilation fails.
   * Returns a valid resource object that displays an error notification
   * in the browser, ensuring the service always returns a response.
   */
  private createFailureResource(
    module: Reactory.Forms.IReactoryFormModule,
    compiledFile: string,
    errorMessage: string,
  ): Reactory.Forms.IReactoryFormResource {
    const failureScript = `
      if(window && window.reactory) {
        var $reactory = window.reactory.api;
        $reactory.createNotification("Compilation error on module ${module.id}: ${errorMessage}", { type: 'error' });
        $reactory.log("Compilation Failure for ${module.id} --> [${errorMessage}]", { module: "${module.id}" }, 'error');
      }
    `;

    try {
      durableWriteFile(compiledFile, failureScript);
    } catch (writeErr) {
      this.context.log(
        `Could not write failure script for module ${module.id}`,
        { writeErr, compiledFile },
        "error",
        ReactoryModuleCompilerService.reactory.id,
      );
    }

    return {
      name: module.id,
      type: "script",
      uri: `${process.env.CDN_ROOT}plugins/__runtime__/lib/${module.id}.min.js?error=true`,
      id: module.id,
      signature: "",
      signatureMethod: "sha1",
      crossOrigin: false,
      signed: false,
      expr: "",
      required: true,
      cacheProvider: "CDN",
    };
  }

  async onStartup(): Promise<any> {
    const runtimePath = path.join(
      process.env.APP_DATA_ROOT,
      "plugins",
      "__runtime__"
    );
    const libPath = path.join(
      process.env.APP_DATA_ROOT,
      "plugins",
      "__runtime__",
      "lib"
    );
    const srcPath = path.join(
      process.env.APP_DATA_ROOT,
      "plugins",
      "__runtime__",
      "src"
    );

    if (!fs.existsSync(runtimePath)) {
      fs.mkdirSync(runtimePath, { recursive: true });
      const files = [
        ".jshintrc",
        ".nvmrc",
        "tsconfig.template.json",
        "package.template.json",
      ];
      this.context.log(
        "Copying runtime files",
        { files },
        "debug",
        ReactoryModuleCompilerService.reactory.id
      );
      const assetsFolder = path.join(
        cwd(),
        `${process.env.APPLICATION_ROOT}/modules/reactory-core/services/assets/RuntimePluginsProject`
      );
      files.forEach((file) => {
        fs.copyFileSync(
          path.join(assetsFolder, file),
          path.join(runtimePath, file)
        );
      });

      try {
        // rename the package.json and tsconfig.json
        fs.renameSync(
          path.join(runtimePath, "package.template.json"),
          path.join(runtimePath, "package.json")
        );
        fs.renameSync(
          path.join(runtimePath, "tsconfig.template.json"),
          path.join(runtimePath, "tsconfig.json")
        );
      } catch (renameException) {
        this.context.log(
          "Error renaming files",
          { renameException },
          "error",
          ReactoryModuleCompilerService.reactory.id
        );
      }

      //run npm install in the runtime folder
      this.context.log(
        "Running NPM Install - this may take ~3 - 5 minutes depending on your connection",
        { runtimePath },
        "debug",
        ReactoryModuleCompilerService.reactory.id
      );
      const { stdout, stderr } = await exec("yarn install", {
        cwd: runtimePath,
      });

      if (stdout.length > 0)
        this.context.log(
          `NPM Install stdout`,
          { stdout },
          "debug",
          ReactoryModuleCompilerService.reactory.id
        );
      if (stderr.length > 0)
        this.context.log(
          `NPM Install stderr`,
          { stderr },
          "debug",
          ReactoryModuleCompilerService.reactory.id
        );
    }
    if (!fs.existsSync(libPath)) fs.mkdirSync(libPath, { recursive: true });
    if (!fs.existsSync(srcPath)) fs.mkdirSync(srcPath, { recursive: true });

    return true;
  }

  getExecutionContext(): Reactory.Server.IReactoryContext {
    return this.context;
  }

  setExecutionContext(context: Reactory.Server.IReactoryContext): boolean {
    this.context = context;
    return true;
  }

  setFileService(fileService: Reactory.Service.IReactoryFileService) {
    this.fileService = fileService;
  }

  static reactory: Reactory.Service.IReactoryServiceDefinition<ReactoryModuleCompilerService> =
    {
      id: "core.ReactoryModuleCompilerService@1.0.0",
      nameSpace: "core",
      description: "Reactory Module Compiler Service",
      name: "ReactoryModuleCompilerService",
      service: (props, context) => {
        return new ReactoryModuleCompilerService(props, context);
      },
      dependencies: [
        {
          id: "core.ReactoryFileService@1.0.0",
          alias: "fileService",
        },
      ],
    };
}

export default ReactoryModuleCompilerService;
