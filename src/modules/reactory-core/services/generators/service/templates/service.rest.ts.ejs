/**
 * <%= description %>
 *
 * Generated by Reactory Service Generator
 * Generated on: <%= generatedDate %>
 * Source: <%= sourceFile %>
 *
 * DO NOT EDIT THIS FILE DIRECTLY - Regenerate from the service definition
 */
import Reactory from '@reactory/reactory-core';
import { service } from '@reactory/server-core/application/decorators';

<% if (authentication && authentication.type !== 'none') { %>
// Authentication utilities
import { getAuthHeaders } from '@reactory/server-core/authentication';
<% } %>

<% /* Generate interface for service config */ %>
interface <%= className %>Config {
  baseUrl: string;
  timeout: number;
  retryConfig: {
    enabled: boolean;
    maxAttempts: number;
    backoff: string;
    initialDelay: number;
    maxDelay: number;
  };
  cachingConfig: {
    enabled: boolean;
    ttl: number;
    store: string;
  };
}

<% /* Generate interfaces for each endpoint's params */ %>
<% if (spec && spec.rest && spec.rest.endpoints) { %>
<% spec.rest.endpoints.forEach(function(endpoint) { %>
<% const paramsInterfaceName = helpers.pascalCase(endpoint.handler) + 'Params'; %>
interface <%= paramsInterfaceName %> {
<% if (endpoint.params && endpoint.params.length > 0) { %>
<% endpoint.params.forEach(function(param) { %>
  /** <%= param.description || param.name %> */
  <%= param.name %><%= param.required ? '' : '?' %>: <%= helpers.mapType(param.type) %>;
<% }); %>
<% } %>
<% if (endpoint.query && endpoint.query.length > 0) { %>
<% endpoint.query.forEach(function(query) { %>
  /** <%= query.description || query.name %> (query parameter) */
  <%= query.name %><%= query.required ? '' : '?' %>: <%= helpers.mapType(query.type) %>;
<% }); %>
<% } %>
<% if (endpoint.body) { %>
  /** Request body */
  body<%= endpoint.body.required ? '' : '?' %>: {
<% if (endpoint.body.properties) { %>
<% Object.keys(endpoint.body.properties).forEach(function(key) { %>
<% const prop = endpoint.body.properties[key]; %>
    <%= key %>: <%= typeof prop === 'string' ? helpers.mapType(prop) : helpers.mapType(prop.type) %>;
<% }); %>
<% } else { %>
    [key: string]: any;
<% } %>
  };
<% } %>
}

<% }); %>
<% } %>

@service({
  id: '<%= id %>',
  name: '<%= name %>',
  nameSpace: '<%= nameSpace %>',
  description: '<%= description %>',
  serviceType: '<%= serviceType %>',
  dependencies: [
<% if (dependencies && dependencies.length > 0) { %>
<% dependencies.forEach(function(dep, index) { %>
    { id: '<%= dep.id %>', alias: '<%= dep.alias %>' }<%= index < dependencies.length - 1 ? ',' : '' %>
<% }); %>
<% } %>
  ],
})
export default class <%= className %> implements Reactory.Service.IReactoryService {
  // Service Properties
  nameSpace: string = '<%= nameSpace %>';
  name: string = '<%= name %>';
  version: string = '<%= version %>';
  description?: string = '<%= description %>';
  tags?: string[] = [<% if (tags && tags.length > 0) { %><% tags.forEach(function(tag, index) { %>'<%= tag %>'<%= index < tags.length - 1 ? ', ' : '' %><% }); %><% } %>];

  // Dependencies
<% if (dependencies && dependencies.length > 0) { %>
<% dependencies.forEach(function(dep) { %>
  private readonly <%= dep.alias %>: any;
<% }); %>
<% } %>

  // Context
  private readonly context: Reactory.Server.IReactoryContext;

  // Configuration
  private readonly config: <%= className %>Config = {
    baseUrl: '<%= spec && spec.rest ? spec.rest.baseUrl : '' %>',
    timeout: <%= timeout || 30000 %>,
    retryConfig: {
      enabled: <%= retry ? retry.enabled : false %>,
      maxAttempts: <%= retry ? (retry.maxAttempts || 3) : 3 %>,
      backoff: '<%= retry ? (retry.backoff || 'exponential') : 'exponential' %>',
      initialDelay: <%= retry ? (retry.initialDelay || 1000) : 1000 %>,
      maxDelay: <%= retry ? (retry.maxDelay || 30000) : 30000 %>,
    },
    cachingConfig: {
      enabled: <%= caching ? caching.enabled : false %>,
      ttl: <%= caching ? (caching.ttl || 300) : 300 %>,
      store: '<%= caching ? (caching.store || 'memory') : 'memory' %>',
    },
  };

  constructor(
    props: Reactory.Service.IReactoryServiceProps,
    context: Reactory.Server.IReactoryContext
  ) {
    this.context = context;

    // Initialize dependencies
<% if (dependencies && dependencies.length > 0) { %>
<% dependencies.forEach(function(dep) { %>
    this.<%= dep.alias %> = (props.dependencies as any)?.<%= dep.alias %>;
<% }); %>
<% } %>

    // Validate required dependencies
<% if (dependencies && dependencies.length > 0) { %>
<% dependencies.forEach(function(dep) { %>
<% if (dep.required !== false) { %>
    if (!this.<%= dep.alias %>) {
      throw new Error('Required dependency <%= dep.alias %> not found');
    }
<% } %>
<% }); %>
<% } %>
  }

  toString(includeVersion?: boolean): string {
    return includeVersion
      ? `${this.nameSpace}.${this.name}@${this.version}`
      : `${this.nameSpace}.${this.name}`;
  }

  toStringWithVersion(): string {
    return `${this.nameSpace}.${this.name}@${this.version}`;
  }

  // ============================================
  // API Methods
  // ============================================

<% if (spec && spec.rest && spec.rest.endpoints) { %>
<% spec.rest.endpoints.forEach(function(endpoint) { %>
<% const paramsInterfaceName = helpers.pascalCase(endpoint.handler) + 'Params'; %>
  /**
   * <%= endpoint.description || endpoint.handler %>
<% if (endpoint.params && endpoint.params.length > 0) { %>
<% endpoint.params.forEach(function(param) { %>
   * @param params.<%= param.name %> - <%= param.description || param.name %>
<% }); %>
<% } %>
   * @returns Promise<any>
   */
  async <%= endpoint.handler %>(params: <%= paramsInterfaceName %>): Promise<any> {
    const method = '<%= endpoint.method %>';
    const pathTemplate = '<%= endpoint.path %>';
    const url = this.buildUrl(pathTemplate, params);

    this.context.debug(
      `<%= className %>.<%= endpoint.handler %> - ${method} ${url}`,
      { params },
      '<%= className %>.<%= endpoint.handler %>'
    );

    try {
<% if (endpoint.cache) { %>
      // Check cache
      const cacheKey = this.getCacheKey('<%= endpoint.handler %>', params);
      const cached = await this.getFromCache(cacheKey);
      if (cached) {
        this.context.debug(`Cache hit for <%= endpoint.handler %>`);
        return cached;
      }
<% } %>

      // Make request
      const response = await this.makeRequest({
        method,
        url,
<% if (endpoint.body) { %>
        body: params.body,
<% } %>
        timeout: <%= endpoint.timeout || 'this.config.timeout' %>,
<% if (endpoint.query && endpoint.query.length > 0) { %>
        query: {
<% endpoint.query.forEach(function(query) { %>
          <%= query.name %>: params.<%= query.name %>,
<% }); %>
        },
<% } %>
      });

<% if (endpoint.cache) { %>
      // Store in cache
      await this.setInCache(cacheKey, response);
<% } %>

      return response;
    } catch (error: any) {
      this.context.error(
        `Error in <%= endpoint.handler %>: ${error.message}`,
        { error, params },
        '<%= className %>.<%= endpoint.handler %>'
      );
      throw error;
    }
  }

<% }); %>
<% } %>
  // ============================================
  // Private Helper Methods
  // ============================================

  /**
   * Build the full URL with path parameters and query string
   */
  private buildUrl(pathTemplate: string, params: any): string {
    // Replace path parameters
    let path = pathTemplate.replace(/{(\w+)}/g, (match, key) => {
      return params[key] !== undefined ? encodeURIComponent(params[key]) : match;
    });

    return `${this.config.baseUrl}${path}`;
  }

  /**
   * Build query string from parameters
   */
  private buildQueryString(query: Record<string, any>): string {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(query)) {
      if (value !== undefined && value !== null) {
        params.append(key, String(value));
      }
    }
    const queryString = params.toString();
    return queryString ? `?${queryString}` : '';
  }

  /**
   * Make an HTTP request with retry logic
   */
  private async makeRequest(options: {
    method: string;
    url: string;
    body?: any;
    timeout?: number;
    query?: Record<string, any>;
  }): Promise<any> {
    const { method, body, timeout, query } = options;
    let url = options.url;

    // Append query string if present
    if (query) {
      url += this.buildQueryString(query);
    }

    const { maxAttempts, backoff, initialDelay, maxDelay } = this.config.retryConfig;
    let lastError: Error;

    for (let attempt = 1; attempt <= (this.config.retryConfig.enabled ? maxAttempts : 1); attempt++) {
      try {
        const headers: Record<string, string> = {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
<% if (spec && spec.rest && spec.rest.headers) { %>
<% Object.entries(spec.rest.headers).forEach(function([key, value]) { %>
          '<%= key %>': '<%= value %>',
<% }); %>
<% } %>
        };

<% if (authentication && authentication.type === 'bearer') { %>
        // Add bearer token
        const token = await this.getAuthToken();
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        }
<% } else if (authentication && authentication.type === 'apiKey') { %>
        // Add API key
        headers['<%= authentication.apiKeyHeader || 'X-API-Key' %>'] = this.getApiKey();
<% } %>

        const fetchOptions: RequestInit = {
          method,
          headers,
        };

        if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
          fetchOptions.body = JSON.stringify(body);
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout || this.config.timeout);
        fetchOptions.signal = controller.signal;

        const response = await fetch(url, fetchOptions);
        clearTimeout(timeoutId);

        if (!response.ok) {
          const errorBody = await response.text();
          throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorBody}`);
        }

        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
          return await response.json();
        }

        return await response.text();
      } catch (error: any) {
        lastError = error;

        if (attempt < maxAttempts && this.config.retryConfig.enabled) {
          const delay = this.calculateBackoff(attempt, backoff, initialDelay, maxDelay);
          this.context.debug(`Retry attempt ${attempt} after ${delay}ms`);
          await this.sleep(delay);
        }
      }
    }

    throw lastError!;
  }

  /**
   * Calculate backoff delay for retries
   */
  private calculateBackoff(
    attempt: number,
    strategy: string,
    initialDelay: number,
    maxDelay: number
  ): number {
    let delay: number;

    switch (strategy) {
      case 'exponential':
        delay = initialDelay * Math.pow(2, attempt - 1);
        break;
      case 'linear':
        delay = initialDelay * attempt;
        break;
      case 'fixed':
      default:
        delay = initialDelay;
    }

    return Math.min(delay, maxDelay);
  }

  /**
   * Sleep for specified milliseconds
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Generate a cache key for a method and parameters
   */
  private getCacheKey(method: string, params: any): string {
    return `${this.nameSpace}.${this.name}:${method}:${JSON.stringify(params)}`;
  }

  /**
   * Get value from cache
   */
  private async getFromCache(key: string): Promise<any> {
    if (!this.config.cachingConfig.enabled) {
      return null;
    }
    // TODO: Implement cache retrieval based on cache store
    return null;
  }

  /**
   * Set value in cache
   */
  private async setInCache(key: string, value: any): Promise<void> {
    if (!this.config.cachingConfig.enabled) {
      return;
    }
    // TODO: Implement cache storage based on cache store
  }

<% if (authentication && authentication.type === 'bearer') { %>
  /**
   * Get authentication token
   */
  private async getAuthToken(): Promise<string | null> {
<% if (authentication.tokenProvider) { %>
    // Get token from token provider service
    const tokenProvider = this.context.getService('<%= authentication.tokenProvider %>');
    if (tokenProvider && typeof tokenProvider.getToken === 'function') {
      return await tokenProvider.getToken();
    }
<% } else if (authentication.token) { %>
    return '<%= authentication.token %>';
<% } %>
    return null;
  }
<% } %>

<% if (authentication && authentication.type === 'apiKey') { %>
  /**
   * Get API key
   */
  private getApiKey(): string {
<% if (authentication.apiKey) { %>
    return '<%= authentication.apiKey %>';
<% } else { %>
    return process.env.<%= helpers.upperSnakeCase(name) %>_API_KEY || '';
<% } %>
  }
<% } %>

  // ============================================
  // Lifecycle Methods
  // ============================================

  getExecutionContext(): Reactory.Server.IReactoryContext {
    return this.context;
  }

  setExecutionContext(context: Reactory.Server.IReactoryContext): boolean {
    (this as any).context = context;
    return true;
  }

  async onStartup(): Promise<any> {
    this.context.debug(
      `<%= className %> started ðŸŸ¢`,
      { baseUrl: this.config.baseUrl },
      '<%= className %>.onStartup'
    );
    return true;
  }
}
