/**
 * Tests for <%= className %>
 *
 * Generated by Reactory Service Generator
 * Generated on: <%= generatedDate %>
 */
import <%= className %> from '../<%= name %>';

// Mock context
const createMockContext = (): any => ({
  partner: {
    _id: 'test-partner-id',
    getSetting: jest.fn(),
  },
  user: {
    _id: 'test-user-id',
  },
  log: jest.fn(),
  debug: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
  getService: jest.fn(),
});

// Mock fetch
global.fetch = jest.fn();

describe('<%= className %>', () => {
  let service: <%= className %>;
  let mockContext: any;
  let mockProps: any;

  beforeEach(() => {
    jest.clearAllMocks();
    mockContext = createMockContext();
    mockProps = {
      dependencies: {
<% if (dependencies && dependencies.length > 0) { %>
<% dependencies.forEach(function(dep) { %>
        <%= dep.alias %>: {
          // Mock <%= dep.alias %> methods as needed
        },
<% }); %>
<% } %>
      },
    };
    service = new <%= className %>(mockProps, mockContext);
  });

  describe('Service Initialization', () => {
    it('should create an instance', () => {
      expect(service).toBeDefined();
      expect(service.name).toBe('<%= name %>');
      expect(service.nameSpace).toBe('<%= nameSpace %>');
      expect(service.version).toBe('<%= version %>');
    });

    it('should return correct string representation', () => {
      expect(service.toString()).toBe('<%= nameSpace %>.<%= name %>');
      expect(service.toString(true)).toBe('<%= nameSpace %>.<%= name %>@<%= version %>');
    });
  });

<% if (spec && spec.rest && spec.rest.endpoints) { %>
<% spec.rest.endpoints.forEach(function(endpoint) { %>
  describe('<%= endpoint.handler %>()', () => {
    beforeEach(() => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({ success: true }),
        headers: new Headers({ 'content-type': 'application/json' }),
      });
    });

    it('should make a <%= endpoint.method %> request to <%= endpoint.path %>', async () => {
      const params = {
<% if (endpoint.params && endpoint.params.length > 0) { %>
<% endpoint.params.forEach(function(param) { %>
        <%= param.name %>: '<%= param.type === 'number' || param.type === 'integer' ? '123' : 'test-value' %>',
<% }); %>
<% } %>
<% if (endpoint.query && endpoint.query.length > 0) { %>
<% endpoint.query.forEach(function(query) { %>
        <%= query.name %>: '<%= query.type === 'boolean' ? 'true' : 'test-query' %>',
<% }); %>
<% } %>
<% if (endpoint.body) { %>
        body: {
          // Add test body data
        },
<% } %>
      };

      const result = await service.<%= endpoint.handler %>(params);

      expect(global.fetch).toHaveBeenCalled();
      expect(result).toBeDefined();
    });

    it('should handle errors gracefully', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        text: jest.fn().mockResolvedValue('Server error'),
      });

      const params = {
<% if (endpoint.params && endpoint.params.length > 0) { %>
<% endpoint.params.forEach(function(param) { %>
        <%= param.name %>: 'test-value',
<% }); %>
<% } %>
      };

      await expect(service.<%= endpoint.handler %>(params)).rejects.toThrow();
      expect(mockContext.error).toHaveBeenCalled();
    });

<% if (endpoint.cache) { %>
    it('should cache responses when caching is enabled', async () => {
      // First call
      await service.<%= endpoint.handler %>({
<% if (endpoint.params && endpoint.params.length > 0) { %>
<% endpoint.params.forEach(function(param) { %>
        <%= param.name %>: 'test-value',
<% }); %>
<% } %>
      });

      // TODO: Verify cache behavior once caching is implemented
      expect(mockContext.debug).toHaveBeenCalled();
    });
<% } %>
  });

<% }); %>
<% } %>

  describe('Lifecycle Methods', () => {
    it('should handle onStartup', async () => {
      const result = await service.onStartup();
      expect(result).toBe(true);
      expect(mockContext.debug).toHaveBeenCalled();
    });

    it('should get and set execution context', () => {
      expect(service.getExecutionContext()).toBe(mockContext);

      const newContext = createMockContext();
      service.setExecutionContext(newContext);
      expect(service.getExecutionContext()).toBe(newContext);
    });
  });
});
