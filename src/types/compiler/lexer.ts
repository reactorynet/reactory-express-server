// Token types specific to the macro language
export type TokenType =
  | 'IDENTIFIER'          // Matches macro names and variable names
  | 'MACRO_START'         // Matches '@' which denotes the start of a macro
  | 'PAREN_OPEN'          // Matches '('
  | 'PAREN_CLOSE'         // Matches ')'
  | 'BRACKET_OPEN'        // Matches '['
  | 'BRACKET_CLOSE'       // Matches ']'
  | 'CURLY_OPEN'          // Matches '{'
  | 'CURLY_CLOSE'         // Matches '}'
  | 'COMMA'               // Matches ','
  | 'SEMICOLON'           // Matches ';'
  | 'ARROW_CHAIN'         // Matches '-->'
  | 'ARROW_BRANCH'        // Matches '-=>'
  | 'VARIABLE'            // Matches '$' followed by a variable name
  | 'STRING_LITERAL'      // Matches string literals, e.g., "hello"
  | 'HEXADECIMAL_LITERAL' // Matches hexadecimal literals, e.g., '0x1234
  | 'BOOLEAN_LITERAL'     // Matches boolean literals, e.g., 'true', 'false'
  | 'EXECUTABLE_STRING_LITERAL' // Matches executable string literals, e.g., `hello ${name} or @print("hello")`
  | 'NUMBER_LITERAL'      // Matches numeric literals, e.g., 123, 45.67
  | 'LOGICAL_OPERATOR'    // Matches logical operators like '&&', '||'
  | 'COMPARISON_OPERATOR' // Matches comparison operators like '==', '!=', '<', '>'
  | 'ARITHMETIC_OPERATOR' // Matches arithmetic operators like '+', '-', '*', '/'
  | 'ASSIGNMENT'          // Matches '='
  | 'EQUALS'              // Matches '==' or '==='
  | 'NOT_EQUALS'          // Matches '!=' or '!=='
  | 'NOT_OPERATOR'        // Matches '!'
  | 'ACL_REQUIRED'        // Matches acl.required
  | 'ACL_DENIED'          // Matches acl.denied
  | 'IF'                  // Matches 'if'
  | 'ELSE'                // Matches 'else'
  | 'ELIF'                // Matches 'elif'
  | 'FOR'                 // Matches 'for'
  | 'WHILE'               // Matches 'while'
  | 'DO'                  // Matches 'do'
  | 'GOTO'                // Matches 'goto'
  | 'WITH'                // Matches 'with'
  | 'YIELD'               // Matches 'yield'
  | 'ASYNC'               // Matches 'async'
  | 'AWAIT'               // Matches 'await'
  | 'SWITCH'              // Matches 'switch'
  | 'CASE'                // Matches 'case'
  | 'DEFAULT'             // Matches 'default'
  | 'BREAK'               // Matches 'break'
  | 'CONTINUE'            // Matches 'continue'
  | 'RETURN'              // Matches 'return'
  | 'TRY'                 // Matches 'try'
  | 'REGEX'               // Matches 'rex'
  | 'CATCH'               // Matches 'catch'
  | 'FINALLY'             // Matches 'finally'
  | 'THROW'               // Matches 'throw'
  | 'LOOP_WHILE'          // Matches 'while'
  | 'LOOP_FOR'            // Matches 'for'
  | 'CONST'               // Matches 'const'
  | 'LET'                 // Matches 'let'
  | 'VAR'                 // Matches 'var'
  | 'NEW'                 // Matches 'new'
  | 'CLASS'               // Matches 'class'
  | 'FUNCTION'            // Matches 'function'
  | 'METHOD'              // Matches 'method'
  | 'PROPERTY'            // Matches 'property'
  | 'IMPORT'              // Matches 'import'
  | 'EXPORT'              // Matches 'export'
  | 'FROM'                // Matches 'from'
  | 'WATCH'               // Matches 'watch'
  | 'DEBUG'               // Matches 'debug'
  | 'LOGGER'              // Matches 'logger'
  | 'PRINT'               // Matches 'print'
  | 'TABLE'               // Matches 'table'
  | 'TRANSFORM'           // Matches 'transform'
  | 'SELECT'              // Matches 'select'
  | 'WHERE'               // Matches 'where'
  | 'ORDER'               // Matches 'order'
  | 'BY'                  // Matches 'by'
  | 'ASC'                 // Matches 'asc'
  | 'DESC'                // Matches 'desc'
  | 'LIMIT'               // Matches 'limit'
  | 'OFFSET'              // Matches 'offset'
  | 'GROUP'               // Matches 'group'
  | 'HAVING'              // Matches 'having'
  | 'JOIN'                // Matches 'join'
  | 'LEFT'                // Matches 'left'
  | 'RIGHT'               // Matches 'right'
  | 'INNER'               // Matches 'inner'
  | 'OUTER'               // Matches 'outer'
  | 'FULL'                // Matches 'full'
  | 'ON'                  // Matches 'on'
  | 'AS'                  // Matches 'as'
  | 'IN'                  // Matches 'in'
  | 'IS'                  // Matches 'is'
  | 'NULL'                // Matches 'null'
  | 'UNDEFINED'           // Matches 'undefined'
  | 'THIS'                // Matches 'this'
  | 'SUPER'               // Matches 'super'
  | 'DELETE'              // Matches 'delete'
  | 'VOID'                // Matches 'void'
  | 'TYPEOF'              // Matches 'typeof'
  | 'INSTANCEOF'          // Matches 'instanceof'
  | 'NUMBER'              // Matches 'number'
  | 'STRING'              // Matches 'string'
  | 'BOOLEAN'             // Matches 'boolean'
  | 'SYMBOL'              // Matches 'symbol'
  | 'OBJECT'              // Matches 'object'
  | 'FUNCTION'            // Matches 'function'
  | 'ANY'                 // Matches 'any'
  | 'UNKNOWN'             // Matches 'unknown'
  | 'NEVER'               // Matches 'never'
  | 'MATH'                // Matches 'math'
  | 'ABS'                 // Matches 'abs'
  | 'ACOS'                // Matches 'acos'
  | 'ASIN'                // Matches 'asin'
  | 'ATAN'                // Matches 'atan'
  | 'ATAN2'               // Matches 'atan2'
  | 'CEIL'                // Matches 'ceil'
  | 'COS'                 // Matches 'cos'
  | 'EXP'                 // Matches 'exp'
  | 'FLOOR'               // Matches 'floor'
  | 'LOG'                 // Matches 'log'
  | 'MAX'                 // Matches 'max'
  | 'MIN'                 // Matches 'min'
  | 'POW'                 // Matches 'pow'
  | 'RANDOM'              // Matches 'random'
  | 'ROUND'               // Matches 'round'
  | 'SIGN'                // Matches 'sign'
  | 'SIN'                 // Matches 'sin'
  | 'SQRT'                // Matches 'sqrt'
  | 'TAN'                 // Matches 'tan'
  | 'CLZ32'               // Matches 'clz32'
  | 'IMUL'                // Matches 'imul'
  | 'FROUND'              // Matches 'fround'
  | 'LOG10'               // Matches 'log10'
  | 'LOG2'                // Matches 'log2'
  | 'LOG1P'               // Matches 'log1p'
  | 'EXPML'               // Matches 'expml'
  | 'COSH'                // Matches 'cosh'
  | 'SINH'                // Matches 'sinh'
  | 'TANH'                // Matches 'tanh'
  | 'ACOSH'               // Matches 'acosh'
  | 'ASINH'               // Matches 'asinh'
  | 'ATANH'               // Matches 'atanh'
  | 'HYPOT'               // Matches 'hypot'
  | 'TRUNC'               // Matches 'trunc'
  | 'SIGNUM'              // Matches 'signum'
  | 'CBR'                 // Matches 'cbr'
  | 'CLB'                 // Matches 'clb'
  | 'EXP2'                // Matches 'exp2'
  | 'COSD'                // Matches 'cosd'
  | 'SIND'                // Matches 'sind'
  | 'TAND'                // Matches 'tand'
  | 'ACOSD'               // Matches 'acosd'
  | 'ASIND'               // Matches 'asind'
  | 'ATAND'               // Matches 'atand'
  | 'ATAN2D'              // Matches 'atan2d'
  | 'COSH'                // Matches 'cosh'
  | 'SINH'                // Matches 'sinh'
  | 'TANH'                // Matches 'tanh'
  | 'ACOSH'               // Matches 'acosh'
  | 'ASINH'               // Matches 'asinh'
  | 'ATANH'               // Matches 'atanh'
  | 'HYPOT'               // Matches 'hypot'
  | 'TRUNC'               // Matches 'trunc'
  | 'SIGNUM'              // Matches 'signum'
  | 'CBR'                 // Matches 'cbr'
  | 'CLB'                 // Matches 'clb'
  | 'EXP2'                // Matches 'exp2'
  | 'COSD'                // Matches 'cosd'
  | 'SIND'                // Matches 'sind'
  | 'TAND'                // Matches 'tand'
  | 'ACOSD'               // Matches 'acosd'
  | 'ASIND'               // Matches 'asind'
  | 'ATAND'               // Matches 'atand'
  | 'ATAN2D'              // Matches 'atan2d'
  | 'DEGREES'             // Matches 'degrees'
  | 'RADIANS'             // Matches 'radians'
  | 'ERROR'               // Used to indicate lexical errors
  | 'KEYWORD'            
  | 'WHITESPACE'          // Matches whitespace
  | 'COMMENT'             // Matches comments
  | 'NEWLINE'             // Matches newlines
  | 'EOF';                // Matches end of file

// Token type definition
export interface Token {
  type: TokenType;
  value: string;
  position: {
    src?: string;
    line: number;
    column: number;
  };
}

export interface TokenizerOptions {
  ignoreWhitespace?: boolean;
  ignoreComments?: boolean;
  ignoreNewLines?: boolean;
  // the input id is used to identify the input source
  inputId?: string;
}

export type Tokenizer = (input: string, options: TokenizerOptions) => Token[];